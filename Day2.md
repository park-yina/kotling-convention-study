# 소스파일 구성

<br>

여러 선언들은(클래스나 최상위 함수, 프로퍼티)같은 서로 밀접하게 관계되어있다면 코틀린 소스파일 내에 배치하는 것이 권장됩니다.
<br>  →코드가 수백줄이 넘는다거나 파일의 크기가 비합리적인 경우 제외
<br>
🟥특히 모든 클라이언트와 관계된 클래스에 대한 확장함수를 정의하는 경우 해당 클래스 자체와 동일한 곳에 파일을 저장해야합니다.
<br>
특정 클라이언트에 적합한 확장함수를 정의할 때에는 해당 클라이언트의 옆에 코드를 배치합니다.
<br>
🟥일부 클래스의 모든 확장자를 보관하기 위해 파일을 생성하는 것은 피해야합니다.

# 클래스 레이아웃
<br>
클래스 내의 내용은 다음과 같은 순서를 따라야합니다

> 첫째 : 프로퍼티(속성)의 선언과 초기화 블록
> <br>
> 둘째 : 보조생성자
> <br>
> 세번째 : 메소드 선언
> <br>
> 네번째 : 동반객체

🟥메소드의 선언을 가시성순이나 알파벳순으로 정렬X,일반 메서드와 확장 메서드를 구분하지마십시오.
<br>
->대신 관련된 내용을 모아서 다른 사람들이 클래스를 읽을 때에 논리적으로 어떤 일이 일어나고있는지 순차적으로 알 수 있도록 하세요
->해당 클래스를 사용하는 코드 옆에 중첩된 클래스를 둡니다.
<br>
클래스가 외부사용을 의도로 하고 클래스의 내부에서 참조되지 않는 경우
<br>
->동반 객체 뒤의 끝에 배치합니다.


<code>
class OrderProcessor {
    private val orderList: MutableList<Order> = mutableListOf()

    // 생성자
    init {
        // 초기화 블록
    }

    // 메서드 - 관련된 기능을 함께 그룹화
    fun addOrder(order: Order) {
        // 주문을 추가하는 메서드
    }

    fun processOrders() {
        // 주문을 처리하는 메서드
    }

    fun cancelOrder(order: Order) {
        // 주문을 취소하는 메서드
    }

    fun calculateTotal() {
        // 주문 총액을 계산하는 메서드
    }

    // 확장 메서드 - 클래스의 주요 기능과 관련된 위치에 배치
    fun Order.printReceipt() {
        // 주문 영수증을 출력하는 확장 메서드
    }
}
</code>
# 인터페이스 레이아웃
<br>
인터페이스를 구현할 때에는, 인터페이스 멤버를 구현멤버와 동일한 순서로 유지합니다.
<br>
필요시에는 구현시 사용되는 추가 전용메서드와의 배치도 가능합니다.
